{-# START_FILE {{name}}.cabal #-}
name:                {{name}}
version:             0.0
cabal-version:       >=1.24

----------------------------------------

build-type:          Simple 
category:            Data 
synopsis:            {{synopsis}} 
description:         
 .
 TODO
 . 
 For an example, see the source of "Example.{{module}}" (either through the @source@ link in the haddocks, or in the @examples/@ directory of the project). 
 .
 Quickstart:
 .
 @
 import {{module}}
 \-- TODO
 @
 .
 Transitive dependencies:
 .
 .
 <<{{name}}-dependencies.png>>
 .

homepage:            http://github.com/{{github-username}}/{{name}}#readme
bug-reports:         http://github.com/{{github-username}}/{{name}}/issues
author:              {{author-name}}
maintainer:          {{author-email}}
copyright:           {{copyright}}
license:             BSD3
license-file:        LICENSE
stability:           provisional
tested-with:
  -- GHC == 8.0.2
  GHC == 8.2.2
  -- GHC == 8.4.2

-- PVP
-- https://wiki.haskell.org/Package_versioning_policy
-- "A.B is known as the major version number, and C the minor version number."

----------------------------------------

extra-source-files:
  README.md
  stack.yaml
  .travis.yml
  HLint.hs
  metadata/dependencies.dot
  metadata/dependencies.png
  metadata/dependencies.txt

-- data-files:
--   data/

----------------------------------------

source-repository head
  type:     git
  location: git://github.com/{{github-username}}/{{name}}.git
  -- location: https://github.com/{{github-username}}/{{name}}

-- source-repository this
--   type:     git
--   location: https://github.com/{{github-username}}/{{name}}/tree/v0.0
  -- update the `source-repository` for `this` package version on every release? 
  -- (i.e. every hackage upload or metadata revision)

----------------------------------------
-- FLAGS

flag examples
  default:     True
  description: Build the examples in @examples/@. They are exposed library modules, for better haddocks and for guaranteeing that they typecheck. 

-- You can disable the doctests test suite with -f-test-doctest.
flag test-doctest
  default:     True 
  description: Run the doctests (with the eponymous `doctest`), called the `test documentation` unit (in this cabal file). 
  manual:      True

-- You can disable the HUnit test suite with -f-test-unit. 
flag test-unit
  default:     True 
  description: Run the unit tests, called the `test unit` unit (in this cabal file).  
  manual:      True

-- You can disable the QuickCheck test suite with -f-test-unit. 
flag test-properties
  default:     True 
  description: Run the property tests (i.e. QuickCheck), called the `test properties` unit (in this cabal file).  
  manual:      True

-- flag test-static
--   default: True 
--   description: Whether to build the `static` test modules; i.e. the fact that they type check correctly is the test, there's nothing (necessarily) "dynamic" that is tested by running. 
--   manual: True

flag test-macros
  default: False
  description: Run any macro tests (i.e. TemplateHaskell), called the `test templates` unit (in this cabal file).  
  manual:  True

flag bench-speed
  default:     True
  description: Execute the benchmarks (which may take a long time).
  manual:      True

flag dump-splices
  default:     False
  description: Make the `template` test suite dump its template-haskell splices.
  manual:      True

-- flag orphans
--  default: False
--  description: Implement orphan instances for TODO, at the cost of more dependencies and, obviously, the presence of orphans. Note: this option is provided for advanced users. 
--  manual: True

----------------------------------------
-- LIBRARY

library
 hs-source-dirs: sources

 ghc-options:

  --------------------
  -- warning groups
  --------------------

  -Wall
  -Wcompat

  --------------------
  -- disabled warnings
  --------------------

  -Wno-unticked-promoted-constructors

  --------------------
  -- enabled warnings
  --------------------

  -- enable
  -Wincomplete-uni-patterns
  -Wincomplete-record-updates
  -Widentities
  -Wmissing-methods

  --------------------
  -- typed-holes
  --------------------

  -- use `typed-holes`, not `undefined`, during development

  -fdefer-typed-holes
  -Wtyped-holes

  --------------------
  -- (miscellaneous warnings)
  --------------------

  -- raise a warning into an error
  -- -Werror=missing-fields

 default-language: Haskell2010

 default-extensions:

   --------------------
   -- "controversial"
   --------------------
   NoImplicitPrelude
   -- NOTE thus every module implicitly has -XNoImplicitPrelude
   
   --------------------
   -- deriving
   --------------------
   AutoDeriveTypeable
   DeriveDataTypeable
   DeriveGeneric
   DeriveFunctor
   DeriveFoldable
   DeriveTraversable
   DeriveLift
   StandaloneDeriving

   --------------------
   -- syntax
   --------------------
   PackageImports
   LambdaCase
   EmptyCase
   TypeOperators
   PostfixOperators
   BangPatterns
   KindSignatures
   NamedFieldPuns
   RecordWildCards
   TupleSections
   MultiWayIf
   DoAndIfThenElse
   EmptyDataDecls
   InstanceSigs
   
   --------------------
   -- typeclasses
   --------------------
   MultiParamTypeClasses
   FlexibleContexts
   FlexibleInstances
   TypeFamilies
   FunctionalDependencies

   --------------------
   -- patterns
   --------------------
   ViewPatterns
   PatternSynonyms

   --------------------
   -- (miscellaneous extensions)
   --------------------
   ScopedTypeVariables

 other-extensions:

   --------------------
   -- macros
   --------------------
   TemplateHaskell
   -- QuasiQuotes

   --------------------
   -- syntax (of literals)
   --------------------
   OverloadedStrings
   OverloadedLists

   --------------------
   -- (miscellaneous extensions)
   --------------------
   -- RebindableSyntax
   -- kinds
   -- DataKinds ConstraintKinds
   -- harmful to inference
   -- GADTs RankNTypes
   -- (miscellaneous)

 -- if impl(ghc >= 8.2)
 --    ghc-options: -Wcpp-undef
 --    -- for `base-feature-macros`

 exposed-modules:
                 {{module}}
                 {{module}}.Types
                 {{module}}.Core
                 {{module}}.Derived

 other-modules:
                 {{module}}.Extra
                 -- Paths_{{identifier}}

 -- autogen-modules:
                 -- Paths_{{identifier}}

 if flag(examples)
    hs-source-dirs: 
      examples
    exposed-modules:
      Examples_{{identifier}}
      Example.{{module}}

 build-depends:

 --------------------
 -- boot libraries / "standard" library
 --------------------

    base >=4.7 && <5
  , text 
  , bytestring
  , transformers
  , mtl
  , containers

  --------------------
  -- my packages
  -- (sboosali on github, sboo on hackage)
  --------------------

  , spiros >=0.2
  -- , enumerate >=0.2 

  --------------------
  -- "extended" standard library 
  --------------------

  , deepseq
  , hashable
  , unordered-containers

  --------------------
  -- ekmett 
  --------------------

  , exceptions
  , lens

  --------------------
  -- (miscellaneous packages)
  --------------------

  -- ,


----------------------------------------
-- TESTS...

----------------------------------------

test-suite doctest
 if (!flag(test-doctest) || impl(ghcjs))
    buildable: False
    -- (`ghcjsi` just doesn't work? or `doctest` needs the GHC API?)

 hs-source-dirs:      test
 main-is:             DocTests.hs
 type:                exitcode-stdio-1.0

 default-language:    Haskell2010
 ghc-options:         -Wall -threaded -rtsopts -with-rtsopts=-N

 build-depends:
    base
  , {{name}}
  , doctest

----------------------------------------

test-suite unit
 if !flag(test-unit)
    buildable: False

 hs-source-dirs: test
 main-is:        UnitTests.hs
 
 type:             exitcode-stdio-1.0
 default-language: Haskell2010
 ghc-options:      
   -Wall -threaded -rtsopts -with-rtsopts=-N

 other-modules:
  {{module}}.Test

 build-depends:
    base
  , {{name}} 
  , tasty
  , tasty-hunit
  -- , hspec      >=2.2

----------------------------------------

test-suite properties 
 if !flag(test-properties)
    buildable: False

 hs-source-dirs:      test
 main-is:             PropertyTests.hs

 type:                exitcode-stdio-1.0
 default-language:    Haskell2010
 ghc-options:         -Wall -threaded -rtsopts -with-rtsopts=-N

 other-modules:
  {{module}}.Properties 

 build-depends:
    base
  , {{name}}
  , tasty
  -- , QuickCheck  >=2.8
  -- , tasty-quickcheck
  -- , smallcheck >=1.1
  -- , tasty-smallcheck
  , hedgehog
  , tasty-hedgehog

----------------------------------------
-- STATIC TESTS

-- test-suite static
--  if !flag(test-static)
--     buildable: False
-- 
--  hs-source-dirs: test
--  main-is:        StaticTests.hs
--  other-modules:
--   StaticTests.Example
-- 
--  type:                exitcode-stdio-1.0
--  default-language:    Haskell2010
--  ghc-options:         -Wall 
-- 
--  build-depends:
--     base
--   , {{name}}

----------------------------------------

-- Template Haskell 
-- Verify that Template Haskell expansion works
-- test-suite macros
--  if !flag(test-macros)
--     buildable: False
-- 
--  hs-source-dirs:      test
--  main-is:             TemplateHaskellTests.hs
--  type:             exitcode-stdio-1.0
--  default-language: Haskell2010
-- 
--  ghc-options:      -Wall -threaded
-- 
--  if flag(dump-splices)
--     ghc-options: -ddump-splices
-- 
--  build-depends:
--     base
--   , {{name}}
--   , template-haskell
--   -- , lens

----------------------------------------
-- BENCHMARKS

benchmark speed
 if !flag(bench-speed)
    buildable: False

 hs-source-dirs:      benchmark
 main-is:             Speed.hs

 type: exitcode-stdio-1.0
 default-language: Haskell2010

 ghc-options:
   -Wall -threaded
   -O2 -fdicts-cheap -funbox-strict-fields

 build-depends:
    base
  , {{name}}
  , criterion
  , deepseq

----------------------------------------
-- EXECUTABLES

executable example-{{name}}
 hs-source-dirs:      executables
 main-is:             Main.hs

 default-language:    Haskell2010
 ghc-options:         -Wall -threaded -rtsopts -with-rtsopts=-N

 build-depends:
    base
  , {{name}}

----------------------------------------
-- NOTES

-- originally generated with this command:  
-- 
-- $ stack new {{name}} https://raw.githubusercontent.com/sboosali/configuration/master/stack/templates/spirosboosalis.hsfiles -p "module:{{module}}" -p "filepath:{{filepath}}"
-- 
-- given this configuration in `~/.stack/config.yaml`: 
-- 
-- templates:
--   params:
--     author-email:    {{author-email}} 
--     author-name:     {{author-name}} 
--     github-username: {{github-username}} 
--     copyright:       {{copyright}}  
--     synopsis:        TODO 

----------------------------------------

{-# START_FILE nix/shell.nix #-}

{-# START_FILE default.nix #-}
import ./nix/{{name}}.nix 


{-# START_FILE upload.sh #-}
#!/bin/sh
set -e
########################################
########################################

{-# START_FILE commit.sh #-}
#!/bin/sh
set -e
########################################
./verify.sh

./dependencies.sh
git add metadata

git commit
########################################

{-# START_FILE verify.sh #-}
#!/bin/sh
set -e
########################################
./configure.sh
./build.sh

./test.sh

./benchmark.sh    || true
./haddock.sh  || true
########################################

{-# START_FILE configure.sh #-}
#!/bin/sh
########################################

nix-shell --run 'cabal configure --enable-tests --enable-benchmarks'

########################################

{-# START_FILE provision.sh #-}
#!/bin/bash
########################################

./environment.sh $@ --run "./configure.sh"

########################################

{-# START_FILE reconfigure.sh #-}
#!/bin/bash
set -e
########################################

cabal2nix . > "nix/{{name}}.nix"

./provision.sh
########################################

{-# START_FILE run.sh #-}
#!/bin/sh
set -e
########################################
cabal build
cabal run example-{{name}}
########################################

{-# START_FILE test.sh #-}
#!/bin/bash
set -e
########################################
time nix-shell --run 'cabal new-test' 
# "$@"
########################################

{-# START_FILE doctest.sh #-}
#!/bin/bash
set -e
########################################
time nix-shell --run 'cabal new-test doctest' 
# "$@"
########################################

{-# START_FILE test-unit.sh #-}
#!/bin/bash
set -e
########################################
time nix-shell --run 'cabal new-test unit' 
# "$@"
########################################

{-# START_FILE test-properties.sh #-}
#!/bin/bash
set -e
########################################
time nix-shell --run 'cabal new-test properties' 
# "$@"
########################################

{-# START_FILE old-haddock.sh #-}
#!/bin/sh
set -e
########################################

# e.g.
# 
# ./haddock.sh --hyperlink-source --all --internal --hoogle
#
# ./haddock.sh --for-hackage --hyperlink-source 

########################################

cabal haddock --hyperlink-source "$@"

########################################

xdg-open ./dist/doc/html/{{name}}/index.html >/dev/null 2>&1

########################################


{-# START_FILE new-haddock.sh #-}
#!/bin/sh
set -e

########################################

cabal new-haddock --haddock-option="--hyperlinked-source"
# not `cabal haddock --hyperlink-source` lol

########################################

ARCHITECTURE="x86_64-linux"
COMPILER="ghc-8.2.2"

PACKAGE="{{name}}"
VERSION="0.0.0"

xdg-open ./dist-newstyle/build/"$ARCHITECTURE/$COMPILER/$PACKAGE-$VERSION"/doc/html/"$PACKAGE"/index.html  >/dev/null 2>&1

########################################

{-# START_FILE haddock.sh #-}
#!/bin/sh
set -e
########################################
source ./new-haddock.sh
########################################

{-# START_FILE benchmark.sh #-}
#!/bin/sh
########################################
time nix-shell --run 'cabal new-bench'
########################################

{-# START_FILE repl.sh #-}
#!/bin/sh
########################################
nix-shell --run 'cabal new-repl {{name}}'
########################################

{-# START_FILE watch.sh #-}
#!/bin/bash
########################################

GHCID_FILE=./ghcid.txt

########################################

echo '...' > "$GHCID_FILE"
# emacsclient "$GHCID_FILE" &

########################################

COMMAND='nix-shell --run "cabal new-repl {{name}}"'
ghcid -o "$GHCID_FILE" --command "$COMMAND"

########################################

{-# START_FILE dependencies.sh #-}
#!/bin/bash
set -e
# DEPENDENCIES:
# stack
# graphviz
# feh
# 
########################################

# get all the nodes in a `.dot` graph
function dot2nodes() {

sed "1,1d; $d" | tr -cd '([:alnum:]|[\-\.]|[\n >])' | grep -F '>' | sed 's/ -> /\n/' | sort | uniq | sed '/^[[:space:]]*$/d'

# NOTES
#
# delete the first line(/row) and the last one
# sed "1,1d; $d"
#
# sed '/^[[:space:]]*$/d
# delete blank lines (matching any sequence of whitespace characters)
# 
# TODO make less hacky, c.f. the filtering of `Cabal`'s dependencies:  grep -E -v "^(Cabal-|ghci-)" 

}

########################################

DIRECTORY=metadata

DOT_FILE="$DIRECTORY/dependencies.dot"
TEXT_FILE="$DIRECTORY/dependencies.txt"
IMAGE_FILE="$DIRECTORY/dependencies.png"

########################################

mkdir -p "$DIRECTORY"

#TODO
# ./environment.sh --pure --arg packageDotNix "./nix/{{name}}_only-library.nix" --arg minimalDependencies true --run "./generate-dependencies.sh > $DOT_FILE"

# generate the transitive dependencies:

stack dot --no-include-base --external > "$DOT_FILE"
# --prune x,y,z

# boot libraries (?):
# 
# array
# binary
# bytestring
# containers
# deepseq
# directory
# ghc-boot-th
# pretty
# process
# rts
# time

########################################

cat "$DOT_FILE" | dot2nodes > "$TEXT_FILE"

echo 
echo '========================================'
echo '[the dependencies]'
echo 
cat "$TEXT_FILE"

echo 
echo '========================================'
echo '[the number of dependencies]'
echo 
cat "$TEXT_FILE" | wc -l 

########################################

echo 
echo '========================================'
echo '[the image]'
echo 
dot -Tpng "$DOT_FILE" -o "$IMAGE_FILE"

feh "$IMAGE_FILE"

########################################

 #       dot draws directed graphs.  It works well on directed acyclic graphs and other graphs that can be drawn as hierarchies  or
 #       have a natural ``flow.''

 #       neato  draws undirected graphs using a ``spring'' model and reducing the related energy (see Kamada and Kawai, Information
 #       Processing Letters 31:1, April 1989).

 #       twopi draws graphs using a radial layout (see G. Wills, Symposium on Graph Drawing GD'97,  September,  1997).  Basically,
 #       one  node  is chosen as the center and put at the origin.  The remaining nodes are placed on a sequence of concentric cir‐
 #       cles centered about the origin, each a fixed radial distance from the previous circle.  All nodes distance 1 from the cen‐
 #       ter  are placed on the first circle; all nodes distance 1 from a node on the first circle are placed on the second circle;
 #       and so forth.

 #       circo draws graphs using a circular layout (see Six and Tollis, GD '99 and ALENEX '99, and Kaufmann and  Wiese,  GD  '02.)
 #       The  tool  identifies  biconnected components and draws the nodes of the component on a circle. The block‐cutpoint tree is
 #       then laid out using a recursive radial algorithm. Edge crossings within a circle are minimized by placing as many edges on
 #       the circle's perimeter as possible.  In particular, if the component is outerplanar, the component will have a planar lay‐
 #       out.  If a node belongs to multiple non‐trivial biconnected components, the layout puts  the  node  in  one  of  them.  By
 #       default, this is the first non‐trivial component found in the search from the root component.

 #       fdp  draws undirected graphs using a ``spring'' model. It relies on a force‐directed approach in the spirit of Fruchterman
 #       and Reingold (cf. Software‐Practice & Experience 21(11), 1991, pp. 1129‐1164).

 #       sfdp also draws undirected graphs using the ``spring'' model described above, but it uses a multi-scale approach  to  pro‐
 #       duce layouts of large graphs in a reasonably short time.

 #       patchwork  draws the graph as a squarified treemap (see M. Bruls et al., ``Squarified treemaps'', Proc. Joint Eurographics
 #       and IEEE TCVG Symp. on Visualization, 2000, pp. 33-42). The clusters of the graph are used to specify the tree.

 #       osage draws the graph using its cluster structure. For a given cluster, each of its subclusters is  laid  out  internally.
 #       Then the subclusters, plus any remaining nodes, are repositioned based on the cluster's pack and packmode attributes.
 # Manual page dot(1) line 20 (press h for help or q to quit)

########################################



{-# START_FILE build.bat #-}
cabal build

{-# START_FILE cabal.config #-}
-- profiling:         True
-- library-profiling: True

{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE cabal.project #-}
-- http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/

packages:
  ./


{-# START_FILE stack.yaml #-}
resolver: nightly-2018-03-12

nix:
  enable: true
  pure:   false
  packages:
  - zlib

packages:
- ./

- location:
    git:    https://github.com/sboosali/spiros
    commit: e0b3a1e2eee3a44a450444bf36f722a6f14d0376
  extra-dep: true
  subdirs: [.] 
# - ../spiros

extra-deps: 
- spiros-0.2



{-# START_FILE sources/{{filepath}}.hs #-}
-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-| 

Examples prefixed by @>>> @ are @doctest@'ed. 
(Ones prefixed by @> @ aren't). 

@

>>> 

@

-}
module {{module}}
 ( module {{module}}.Types
 , module {{module}}.Core
 , module {{module}}.Derived

 -- , module {{module}}
 ) where
----------------------------------------
import {{module}}.Types
import {{module}}.Core
import {{module}}.Derived
----------------------------------------

----------------------------------------

{-# START_FILE sources/{{filepath}}/Types.hs #-}
-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-| The primary types. 

This module mostly defines types 
(i.e. @data@, @newtype@, @type@, @class@, @instance@);
it also defines whatever functions are necessary for those types' instances.

-}
module {{module}}.Types where
import {{module}}.Extra()

import "spiros" Prelude.Spiros.Classes

----------------------------------------

----------------------------------------

{-# START_FILE sources/{{filepath}}/Core.hs #-}
-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-| The core definitions. 

-}
module {{module}}.Core where
import {{module}}.Extra()
import {{module}}.Types()

----------------------------------------

----------------------------------------

{-# START_FILE sources/{{filepath}}/Derived.hs #-}
-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-| Definitions that are derived from the core definitions (in "{{module}}.Core"). 

-}
module {{module}}.Derived where
import {{module}}.Extra()
import {{module}}.Types()
import {{module}}.Core()

----------------------------------------



----------------------------------------

{-# START_FILE sources/{{filepath}}/Extra.hs #-}
-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-|

-}
module {{module}}.Extra
 ( module Prelude.Spiros
 -- , module {{module}}.Extra
 -- , module X
 ) where

----------------------------------------

import "spiros" Prelude.Spiros
-- import as X

----------------------------------------

{-# START_FILE examples/Examples_{{identifier}}.hs #-}
-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-|

-}
module Examples_{{identifier}} 
  ( module Example.{{module}}
  ) where
----------------------------------------
import Example.{{module}}
----------------------------------------

{-# START_FILE examples/Example/{{filepath}}.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-} 
    -- to test inference

-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

{-| This module provides a simple example program. 


Being a @library@ module, it's typechecked with the package, 
and thus should always build.

Only public interfaces are imported (i.e. no @.Internal@s),
all required language extensions are listed within this module,
and there are minimal other dependencies. 


Doctests:

@
TODO
@

Please read the source too <https://hackage.haskell.org/package/{{name}}/docs/src/{{module}}-Example.html (direct Hackage link)>. 


Executable:

'main' is executed by the @{{name}}-example@ executable. 


-}
module {{module}}.Example where

import {{module}}()

import System.Environment

import "base" Prelude

----------------------------------------
-- Main

{-|

Running...


@cabal@ (old):

@
cabal build && cabal run example-{{name}}
@


@cabal@ (new):

@
cabal new-build && ./dist-newstyle/<...>/example-{{name}}
@


@stack@:

@
stack build && stack exec -- example-{{name}}
@

-}
main :: IO ()
main = do
 arguments <- getArgs >>= \case
  [s] -> return (s)
  _ -> return ("")
 mainWith arguments

mainWith s = do
 putStrLn s
 putStrLn "({{module}}.Example...)"

----------------------------------------
-- Example

----------------------------------------

{-# START_FILE test/UnitTests.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
-- {-# OPTIONS_GHC -F -pgmF hspec-discover #-}

{-# LANGUAGE PackageImports #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

import {{module}}.Test

import "tasty" Test.Tasty

----------------------------------------

main :: IO ()
main = defaultMain tests

----------------------------------------

{-# START_FILE test/{{filepath}}/Test.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE PackageImports #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

module {{module}}.Test where

--import {{module}} 

----------------------------------------

import "tasty"       Test.Tasty
import "tasty-hunit" Test.Tasty.HUnit

----------------------------------------

tests :: TestTree
tests = testCase "Example unit test" $ do
  assertion

assertion :: Assertion
assertion = do 

    2 + 2      @?= (4 :: Int)   -- `actual`   on left
    
    (6 :: Int) @=? 3 + 3        -- `expected` on left
    
    assertBool "the list is not empty" $ null []

----------------------------------------

{-NOTES


testCase :: TestName -> Assertion -> TestTree


-- | Asserts that the specified actual value is equal to the expected value
--   (with the expected value on the left-hand side).
(@=?)
  :: (Eq a, Show a, HasCallStack)
  => a -- ^ The expected value
  -> a -- ^ The actual value
  -> Assertion
expected @=? actual = assertEqual "" expected actual

-- | Asserts that the specified actual value is equal to the expected value
--   (with the actual value on the left-hand side).
(@?=)
  :: (Eq a, Show a, HasCallStack)
  => a -- ^ The actual value
  -> a -- ^ The expected value
  -> Assertion
actual @?= expected = assertEqual "" expected actual

-- | An infix and flipped version of 'assertBool'. E.g. instead of
--
-- >assertBool "Non-empty list" (null [1])
--
-- you can write
--
-- >null [1] @? "Non-empty list"
--
-- '@?' is also overloaded to accept @'IO' 'Bool'@ predicates, so instead
-- of
--
-- > do
-- >   e <- doesFileExist "test"
-- >   e @? "File does not exist"
--
-- you can write
--
-- > doesFileExist "test" @? "File does not exist"
(@?) :: (AssertionPredicable t, HasCallStack)
  => t          -- ^ A value of which the asserted condition is predicated
  -> String     -- ^ A message that is displayed if the assertion fails
  -> Assertion
predi @? msg = assertionPredicate predi >>= assertBool msg


-}
----------------------------------------

{-# START_FILE test/{{filepath}}/Property.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

-- {-# LANGUAGE  #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

module {{module}}.Property where
--import {{module}}

----------------------------------------


{-# START_FILE test/DocTests.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE PackageImports #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

import "doctest" Test.DocTest (doctest)

import "base" System.Environment (getArgs)

----------------------------------------

main :: IO ()
main = do
  arguments <- getArgs
  doctest $ concat
    [ sources
    , extensions
    , headers
    , arguments
    ]

----------------------------------------

sources :: [String]
sources = sources2flags
  [ "sources/"
  , "examples/"
  ] 
  where
  sources2flags :: [String] -> [String]
  sources2flags = id

headers :: [String]
headers = headers2flags
  [ "include/"
  ]
  where
  headers2flags :: [String] -> [String]
  headers2flags = fmap ("-I"++) 
  -- -I<dir> adds <dir> to the #include search path.

extensions :: [String]
extensions = extensions2flags "NoImplicitPrelude PackageImports AutoDeriveTypeable DeriveDataTypeable DeriveGeneric DeriveFunctor DeriveFoldable DeriveTraversable LambdaCase EmptyCase TypeOperators PostfixOperators ViewPatterns BangPatterns KindSignatures NamedFieldPuns RecordWildCards TupleSections MultiWayIf DoAndIfThenElse EmptyDataDecls InstanceSigs MultiParamTypeClasses FlexibleContexts FlexibleInstances TypeFamilies FunctionalDependencies ScopedTypeVariables StandaloneDeriving"
  where
  extensions2flags :: String -> [String]
  extensions2flags = fmap ("-X"++) . words

----------------------------------------
{-

There's two sets of GHC extensions involved when running Doctest:

- The set of GHC extensions that are active when compiling the module code (excluding the doctest examples). The easiest way to specify these extensions is through LANGUAGE pragmas in your source files. (Doctest will not look at your cabal file.)

- The set of GHC extensions that are active when executing the Doctest examples. (These are not influenced by the LANGUAGE pragmas in the file.) The recommended way to enable extensions for Doctest examples is to switch them on like this:

    -- |
    -- >>> :set -XTupleSections
    -- >>> fst' $ (1,) 2
    -- 1
    fst' :: (a, b) -> a
    fst' = fst

Alternatively you can pass any GHC options to Doctest, e.g.:

    doctest -XCPP Foo.hs



sources/Prelude/Spiros/Reexports.hs:2:0: error:
     fatal error: base-feature-macros.h: No such file or directory
     #include <base-feature-macros.h>

-}

{-# START_FILE test/PropertyTests.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE PackageImports #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

import "tasty" Test.Tasty

import {{module}}.Properties
 
----------------------------------------

main :: IO ()
main = defaultMain $ properties

----------------------------------------

{-# START_FILE test/{{module}}/Properties.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE PackageImports #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

-- import {{module}} 

import "tasty"          Test.Tasty
import "tasty-hedgehog" Test.Tasty.Hedgehog

import "hedgehog" Hedgehog

import qualified "bytestring" Data.ByteString.Lazy as B
import           "bytestring" Data.ByteString.Lazy (ByteString)

----------------------------------------

properties :: TestTree
properties = 

  testGroup "list properties (stub)"
    [ testProperty "reverse is involutive" 
        property_reverse_involutive

    , testProperty "sort is idempotent" 
        property_sort_idempotent

    , testProperty "Fermat's last theorem" $
        \x y z n -> (n :: Integer) >= 3 ==>
            x^n + y^n /= (z^n :: Integer)
    ]

property_reverse_involutive :: Property
property_reverse_involutive = \(list :: [Int]) ->
 list == reverse (reverse list)

property_sort_idempotent :: Property
property_sort_idempotent = \(list :: [Int]) ->
 sort list == sort (sort list)

----------------------------------------

{-NOTES

-- | Create a 'Test' from a Hedgehog property
testProperty :: T.TestName -> Property -> T.TestTree
testProperty name prop = T.singleTest name (HP name prop)

-}

----------------------------------------

{-# START_FILE test/golden/{{name}}.golden #-}
{{name}}
{-# START_FILE test/GoldenTests.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE PackageImports #-}
{-# LANGUAGE OverloadedStrings #-}

module GoldenTests where
----------------------------------------

import "tasty"       Test.Tasty
import "tasty-golden" Test.Tasty.Golden

import qualified "bytestring" Data.ByteString.Lazy as B
import            "bytestring" Data.ByteString.Lazy (ByteString)

----------------------------------------

golden_stub :: TestTree
golden_stub = goldenVsString goldenName goldenFile goldenAction
 where
 goldenName   = "golden test (stub)"
 goldenFile   =  "test/golden/{{name}}.golden" 
 goldenAction = do
     return "{{name}}"

----------------------------------------

{-NOTES

goldenVsString "golden test (stub)" "test/golden/{{name}}.golden" (return "{{name}}")


goldenVsString 

:: TestName	
test name

-> FilePath	
path to the «golden» file (the file that contains correct output)

-> IO ByteString	
action that returns a string

-> TestTree	
the test verifies that the returned string is the same as the golden file contents

Compare a given string against the golden file contents


Note about filenames. They are looked up in the usual way, thus relative names are relative to the processes current working directory. It is common to run tests from the package's root directory (via cabal test or cabal install --enable-tests), so if your test files are under the tests/ subdirectory, your relative file names should start with tests/ (even if your test.hs is itself under tests/, too).




Note about line endings. The best way to avoid headaches with line endings (when running tests both on UNIX and Windows) is to treat your golden files as binary, even when they are actually textual.

This means:

When writing output files from Haskell code, open them in binary mode (see openBinaryFile, withBinaryFile and hSetBinaryMode). This will disable automatic \n -> \r\n conversion on Windows. For convenience, this module exports writeBinaryFile which is just like writeFile but opens the file in binary mode. When using ByteStrings note that Data.ByteString and Data.ByteString.Lazy use binary mode for writeFile, while Data.ByteString.Char8 and Data.ByteString.Lazy.Char8 use text mode.
Tell your VCS not to do any newline conversion for golden files. For git check in a .gitattributes file with the following contents (assuming your golden files have .golden extension):
*.golden	-text
On its side, tasty-golden reads and writes files in binary mode, too.

Why not let Haskell/git do automatic conversion on Windows? Well, for instance, tar will not do the conversion for you when unpacking a release tarball, so when you run cabal install your-package --enable-tests, the tests will be broken.

-}

{-# START_FILE test/TemplateHaskellTests.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE CPP #-}

module Main where

import Control.Lens

----------------------------------------

-- NOTE below we mock out any TemplateHaskell tests with `lens`'s
-- if your package doesn't provide TemplateHaskell-macros,
-- remove this file and the stanza

data Bar a b c = Bar { _baz :: (a, b) }
makeLenses ''Bar

checkBaz :: Iso (Bar a b c) (Bar a' b' c') (a, b) (a', b')
checkBaz = baz

main :: IO ()
main = putStrLn "[tests/TemplateHaskellTests.hs] ok"

----------------------------------------

{-# START_FILE test/HLintTest.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

-- (by ekmett via lens)
-- This module runs HLint on the source tree.

module Main where

import Control.Monad
import Language.Haskell.HLint
import System.Environment
import System.Exit

{-|

Usage:

you can hide code from hlint, 
by using cpp in the source:

    #ifndef HLINT
    ...
    #endif

-}
main :: IO ()
main = do
    args <- getArgs
    hints <- hlint $ ["src", "--cpp-define=HLINT", "--cpp-ansi"] ++ args
    unless (null hints) exitFailure
    

{-# START_FILE executables/Main.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
-- {-# LANGUAGE  #-}
import qualified Example.{{module}} as Example
main = do
   Example.main

{-# START_FILE benchmark/Speed.hs #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

{-# LANGUAGE PackageImports #-}
-- {-# LANGUAGE OverloadedStrings #-}
-- {-# LANGUAGE OverloadedLists #-}

import {{module}}

import "criterion" Criterion.Main

----------------------------------------

main :: IO ()
main = defaultMain [
  bgroup "{{module}}"

    [ bench "normal form" $
       nf length [1..1000::Int]

    , bench "weak head normal form" $
       whnf length [1..1000::Int]
    ]

  ]

----------------------------------------


{-# START_FILE .travis.yml #-}
# https://docs.travis-ci.com/user/languages/haskell

#   - 8.0
ghc:
  - 7.10
  - 7.8

# install: stack install

# script: stack test

notifications:
  email:
    - {{author-email}}

{-# START_FILE .ghci #-}


{-# START_FILE HLint.hs #-}
{-# LANGUAGE PackageImports, TemplateHaskell #-}
import "hint" HLint.Default
import "hint" HLint.Dollar
import "hint" HLint.Generalise
ignore "Use unwords"
ignore "Use map once"
ignore "Use =<<"
ignore "Functor law"


{-# START_FILE .gitignore #-}
# my
ignore/ 
temporary/ 
TODO

# Haskell
.styx/
cabal.project.local
dist-newstyle/
dist/
cabal-dev
*.o
*.hi
*.chi
*.chs.h
.virtualenv
.hsenv
ghcid.txt
.cabal-sandbox/
cabal.sandbox.config
cabal.config
report.html
.stack-work/

# nix
result
result/

# Emacs
\#*
*~
.#*
\#*\#
*.log
TAGS
.projectile

# OS X
.DS_Store


{-# START_FILE LICENSE #-}
Copyright {{author-name}} (c) 2018

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



{-# START_FILE appveyor.yml #-}

version: 0.0.0.{build}

shallow_clone: true

cache:
  - "%APPDATA%\\stack"
  - .stack-work

build_script:
  - choco install haskell-stack
  - stack --no-terminal setup > NUL
  - stack --no-terminal exec pacman -- -Syu --force --noconfirm --noprogressbar
  - stack --no-terminal exec pacman -- -Syu --force --noconfirm --noprogressbar
  - stack --no-terminal exec pacman -- -Syu --force --noconfirm --noprogressbar
  - stack --no-terminal build --haddock


{-# START_FILE CHANGELOG.md #-}

0.0.0 
----

* nothing 


{-# START_FILE NOTES.md #-}

========================================

========================================

The initial repository structure was automatically generated by:

```
# New project scaffolding
# 
# requires:
# nix, cabal2nix, sed (/stdenv), stack, cabal-install, hscolour,
#
# NOTES
# function definition is subshell ("(" not "{")
# 
# '''You may directly use a subshell as your function definition and set it to exit immediately with set -e. This would limit the scope of set -e to the function subshell only and would later avoid switching between set +e and set -e.
# In addition, you can use a variable assignment in the if test and then echo the result in an additional else statement.'''
# https://stackoverflow.com/questions/4072984/set-e-in-a-function
# 
function new-haskell-project () (
    set -e

    PACKAGE="$1"
    MODULE="$2"
    _FILEPATH="$3"

    MESSAGE='h-new PACKAGE MODULE FILEPATH''\n''e.g. h-new workflow-core Workflow.Core Workflow/Core'

    if [ "$#" -ne 3 ]; then
        echo -e "$MESSAGE"
	return 1
        # NOTE `return` v `exit`?
        # `return`, in the subshell-defined-function, still seems to work.
    fi

    LOCAL_TEMPLATE=~/.stack/templates/spirosboosalis.hsfiles
    REMOTE_TEMPLATE='https://raw.githubusercontent.com/sboosali/config/master/stack/templates/spirosboosalis.hsfiles'
    if [ -f "$LOCAL_TEMPLATE" ]; then
	TEMPLATE="$LOCAL_TEMPLATE"
    else
	TEMPLATE="$REMOTE_TEMPLATE"
    fi

    echo
    echo "[TEMPLATE]"
    echo "$TEMPLATE"
    echo

    stack new "$PACKAGE" "$TEMPLATE" -p module:"$MODULE" -p filepath:"$_FILEPATH" || true # ignore failure
    # -p synopsis:"$SYNOPSIS"

    if ! cd "$PACKAGE"; then
        echo -e "$MESSAGE"
	return 1
    fi

    # patch documentation
    # e.g. "Cards.Common-Example.html" -> "Cards-Common-Example.html"
    STRING_FROM="$MODULE"-Example.html
    STRING_INTO="$(echo "$MODULE"-Example | sed 's/\./-/g')".html
    sed -i  s/"$STRING_FROM"/"$STRING_INTO"/g  sources/"$_FILEPATH"/Example.hs
    sed -i  s/"$STRING_FROM"/"$STRING_INTO"/g  README.md

    # patch cabal file
    # e.g. "Paths_reflex-vinyl" -> "Paths_reflex_vinyl"
    STRING_FROM_2="Paths_$PACKAGE"
    STRING_INTO_2="$(echo "$STRING_FROM_2" | sed 's/-/_/g')"
    sed -i  s/"$STRING_FROM_2"/"$STRING_INTO_2"/g "$PACKAGE.cabal"

    NIX_DEFAULT_FILE="$PACKAGE-default.nix"
    cabal2nix .         > "$NIX_DEFAULT_FILE"

    NIX_SHELL_FILE="$PACKAGE-shell.nix"
    cabal2nix . --shell > "$NIX_SHELL_FILE" 

    # SC2035
    chmod 700 ./*.sh

    echo
    echo "========================================"
    echo "[Building Everything...]"
    echo "========================================"
    echo

    # try to open a tab in the default browser to create a GitHub repository,
    # during the build (which should take a minute)
    GITHUB_URL=https://github.com/new
    xdg-open "$GITHUB_URL" 2>/dev/null || open "$GITHUB_URL" 2>/dev/null || true # ignore failure

    nix-shell "$NIX_SHELL_FILE" --arg doBenchmark true --arg doTest true --run 'cabal configure --enable-tests --enable-benchmarks'

    # nix-shell "$SHELL_FILE" --arg doBenchmark true 
    cabal build
    cabal run "example-$PACKAGE"
    cabal test || true # ignore failure
    cabal bench || true # ignore failure
    cabal haddock --haddock-option="--hyperlinked-source" || true # ignore failure

    # (nix-shell && cabal build && cabal run example-$PACKAGE)

    echo
    echo "========================================"
    echo "[Initializing Repository...]"
    echo "========================================"
    echo
    git init
    git add .
    git commit -m '1st'
    git remote add origin "git@github.com:sboosali/$PACKAGE".git
    git push -u origin master
)
```
========================================


{-# START_FILE README.md #-}
[![Build Status](https://secure.travis-ci.org/{{github-username}}/{{name}}.svg)](http://travis-ci.org/{{github-username}}/{{name}})
[![Hackage](https://img.shields.io/hackage/v/{{name}}.svg)](https://hackage.haskell.org/package/{{name}})

# {{name}}

{{synopsis}} 

## Example

```
import {{module}}

-- TODO
```

## Links

[Hackage](https://hackage.haskell.org/package/{{name}})

[Example module source](https://hackage.haskell.org/package/{{name}}/docs/src/{{module}}-Example.html). 

## Development

### Nix

These nix files:

* `{{name}}-default.nix` 
* `{{name}}-shell.nix` 

were automatically created by the `cabal2nix` command, and can be regenerated with `./reconfigure.sh`. They shouldn't be edited manually. 

While the other nix files:

* `default.nix` 
* `shell.nix` 

import their respecitve autogen'd files, but can (and should) be edited manually when necessary. 

If, you've forked this and have rewritten your own custom nix file for development (e.g. you're on OSX, or you need an older compiler version), please suffix it with that environment (e.g. `osx-shell.nix` or `ghc-7-10-03.nix`), and submit a pull request. Ditto for `stack.yaml` files. 



{-# START_FILE link-default-dot-nix.sh #-}

#!/bin/bash
set -e
########################################

# Usage:
# 
# ./link-default-dot-nix.sh 
# ./link-default-dot-nix.sh -f
#

#ARGUMENTS="$@"

########################################

function absolute-path {
 echo $(cd $(dirname "$1"); pwd)/$(basename "$1")

 # versus `readlink`, which
 # /reads links/, which will be by cosntruction identical
}

########################################

# symlink to the package's autogenerated-via-cabal2nix .nix file

PACKAGE_DOT_NIX=./nix/{{name}}.nix

cabal2nix . > "$PACKAGE_DOT_NIX"

ln -s $@ "$(absolute-path $PACKAGE_DOT_NIX)" default.nix

echo
cat default.nix
echo
ls -l default.nix

########################################

# A symlink actually stores the path you give literally, as a string¹. That means your link ~/mylink contains "." (one character). When you access the link, that path is interpreted relative to where the link is, rather than where you were when you made the link.
# Instead, you can store the actual path you want in the link:
#
# ln -s "$(pwd)" ~/mylink
# 



{-# START_FILE environment.sh #-}
#!/bin/bash
set -e
########################################

# e.g.
#
# ./environment.sh
#
# ./environment.sh 802
# ./environment.sh js
#
# ./environment.sh --argstr compiler ghc802
# ./environment.sh --argstr compiler ghcjs
#
# ./environment.sh js --arg isProfiled true 
#
# ./environment.sh  --arg withHoogle true  --arg isProfiled true  --arg isTested true  --arg isBenchmarked true  --arg isDocumented true  --arg isHyperlinked true  --arg isDwarf true  --argstr whichLinker gold  --argstr whichObjectLibrary static
#
#

########################################

# ghc7103, ghc802, ghc822, ghc841, ghcjs

DEFAULT_COMPILER="default"
# DEFAULT_COMPILER="ghc822"

COMPILER="$DEFAULT_COMPILER"
#COMPILER="${1}"
# bash default argument

DEFAULT_INTEGER_SIMPLE=false

INTEGER_SIMPLE="$DEFAULT_INTEGER_SIMPLE"

########################################

# aliases for nixpkgs' compiler identifiers:

case "$1" in
 
7.10|7.10.3)
  COMPILER="ghc7103"
  shift 1
  ;;
8.0|8.0.2)
  COMPILER="ghc802"
  shift 1
  ;;
8.2|8.2.2)
  COMPILER="ghc822"
  shift 1
  ;;
8.4|8.4.1)
  COMPILER="ghc841"
  shift 1
  ;;

7)
  COMPILER="ghc7103"
  shift 1
  ;;
8)
  COMPILER="ghc841"
  shift 1
  ;;

710|7103)
  COMPILER="ghc7103"
  shift 1
  ;;
80|802)
  COMPILER="ghc802"
  shift 1
  ;;
82|822)
  COMPILER="ghc822"
  shift 1
  ;;
84|841)
  COMPILER="ghc841"
  shift 1
  ;;

HEAD|head)
  COMPILER="ghcHEAD"
  shift 1
  ;;

j|js)
  COMPILER="ghcjs"
  shift 1
  ;;

jHEAD|jhead|jsHEAD|jshead|ghcjshead)
  COMPILER="ghcjsHEAD"
  shift 1
  ;;

i)
  COMPILER="$DEFAULT_COMPILER"
  INTEGER_SIMPLE=true
  shift 1
  ;;

ghc7103)
  COMPILER="ghc7103"
  shift 1
  ;;
    
ghc802)
  COMPILER="ghc802"
  shift 1
  ;;
    
ghc822)
  COMPILER="ghc822"
  shift 1
  ;;

ghc841)
  COMPILER="ghc842"
  shift 1
  ;;
    
ghc841)
  COMPILER="ghc842"
  shift 1
  ;;
    
ghcHEAD)
  COMPILER="ghcHEAD"
  shift 1
  ;;
    
ghcjs)
  COMPILER="ghcjs"
  shift 1
  ;;
    
ghcjsHEAD)
  COMPILER="ghcjsHEAD"
  shift 1
  ;;

#TODO    
# integer-simple)
#   COMPILER="integer-simple"
#   shift 
#   ;;

i80|i802|i8.0.2|integer-simple-8.0.2)
  COMPILER="ghc801"
  INTEGER_SIMPLE=true
  shift 1
  ;;

i82|i822|i8.2.2|integer-simple|integer-simple-8.2.2)
  COMPILER="ghc822"
  INTEGER_SIMPLE=true
  shift 1
  ;;

i841|i8.4.1|integer-simple-8.4.1)
  COMPILER="ghc841"
  INTEGER_SIMPLE=true
  shift 1
  ;;

i84|i842|i8.4.2|integer-simple-8.4.2)
  COMPILER="ghc842"
  INTEGER_SIMPLE=true
  shift 1
  ;;

default)
  COMPILER="$DEFAULT_COMPILER"
  shift 1
  ;;

*)
  COMPILER="$DEFAULT_COMPILER"
  ;;

esac

########################################

echo "[COMPILER]" "$COMPILER" 
echo 
echo "[INTEGER-SIMPLE]" "$INTEGER_SIMPLE" 
echo 
echo "[OTHER ARGUMENTS]" "$@"
echo

nix-shell --show-trace --argstr compiler "$COMPILER" --arg integer-simple "$INTEGER_SIMPLE" "$@"


{-# START_FILE cabal.sh #-}
#!/bin/bash
set -e
########################################

# e.g.
#
# ./cabal.sh
#
# ./cabal.sh new build
# ./cabal.sh old build
# 
# ./cabal.sh new-repl
# ./cabal.sh repl
#
# ./cabal.sh 802
# ./cabal.sh js
#
# ./cabal.sh --argstr compiler ghc802
# ./cabal.sh --argstr compiler ghcjs
#
# ./cabal.sh old 841 --arg isProfiled true 
# ./cabal.sh new js  --arg isProfiled true 
#
# ./cabal.sh  --arg withHoogle true  --arg isProfiled true  --arg isTested true  --arg isBenchmarked true  --arg isDocumented true  --arg isHyperlinked true  --arg isDwarf true  --argstr whichLinker gold  --argstr whichObjectLibrary static
#
#

########################################

DEFAULT_COMMAND="cabal new-build"

COMMAND="$DEFAULT_COMMAND"

########################################

# aliases for cabal new-versus-old:
case "$1" in

new)
  SUBCOMMAND="${2:?}"
  COMMAND="cabal new-$SUBCOMMAND"
  shift 2
  ;;

old)
  SUBCOMMAND="${2:?}"
  COMMAND="cabal $SUBCOMMAND"
  shift 2
  ;;

build|repl|test|bench|run|haddock)
  SUBCOMMAND="${1}"
  COMMAND="cabal $SUBCOMMAND"
  shift 1
  ;;

new-build|new-repl|new-test|new-bench|new-run|new-haddock)
  SUBCOMMAND="${1}"
  COMMAND="cabal $SUBCOMMAND"
  shift 1
  ;;

*)
  ;;

esac

# case "$1" in

# new)
#   SUBCOMMAND="${2}"
#   COMMAND="cabal new-$SUBCOMMAND"
#   shift 1
#   ;;

# old)
#   SUBCOMMAND="${2}"
#   COMMAND="cabal $SUBCOMMAND"
#   shift 1
#   ;;

# build|repl|test|bench|run|haddock)
#   shift 1
#   ;;

# *)
#   ;;

# esac

########################################

echo "$@"
echo

./environment.sh $@ --run "$COMMAND"



{-# START_FILE build.sh #-}
#!/bin/bash
set -e
########################################

# e.g.
#
# ./build.sh
#
# ./build.sh new
# ./build.sh old
#
# ./build.sh 802
# ./build.sh js
#
# ./build.sh --argstr compiler ghc802
# ./build.sh --argstr compiler ghcjs
#
# ./build.sh old 841 --arg isProfiled true 
# ./build.sh new js  --arg isProfiled true 
#
# ./build.sh  --arg withHoogle true  --arg isProfiled true  --arg isTested true  --arg isBenchmarked true  --arg isDocumented true  --arg isHyperlinked true  --arg isDwarf true  --argstr whichLinker gold  --argstr whichObjectLibrary static
#
#

########################################

DEFAULT_COMMAND="cabal new-build"

COMMAND="$DEFAULT_COMMAND"

########################################

# aliases for cabal new-versus-old:

case "$1" in

new)
  COMMAND="cabal new-build"
  shift 1
  ;;

old)
  COMMAND="cabal build"
  shift 1
  ;;

*)
  ;;
esac

########################################

echo "$@"
echo

./environment.sh $@ --run "$COMMAND"



{-# START_FILE install.sh #-}
#!/bin/bash
set -e
########################################
nix-build --show-trace shell.nix
########################################
# e.g.
# 
# Using install prefix: /nix/store/<hash>-<name>-<version>
#
# Executables installed in:
# /nix/store/<hash>-<name>-<version>/bin
#
# Libraries installed in:
# /nix/store/<hash>-<name>-<version>/lib/<compiler>/<name>-<version>
#
# Dynamic Libraries installed in:
# /nix/store/<hash>-<name>-<version>/lib/<compiler>/<arch>-<os>-<compiler>
#
# Private executables installed in:
# /nix/store/<hash>-<name>-<version>/libexec/<arch>-<os>-<compiler>/<name>-<version>
#
# Data files installed in:
# /nix/store/<hash>-<name>-<version>/share/<arch>-<os>-<compiler>/<name>-<version>
#
# Documentation installed in:
# /nix/store/<hash>-<name>-<version>/share/doc/<arch>-<os>-<compiler>/<name>-<version>
#
# Configuration files installed in:
# /nix/store/<hash>-<name>-<version>/etc
#
########################################


{-# START_FILE shell.nix #-}
{ nixpkgs ? import <nixpkgs> {}

, packageDotNix ? ./nix/{{name}}.nix # ./.

, compiler ? "default"
/* =
"ghc7103"
"ghc802"
"ghc822"
"ghc841"
"ghcHEAD"
"ghc7103Binary"
"ghc821Binary"
"ghcjs"
"ghcjsHEAD"
"integer-simple"
*/

, integer-simple ? false
/* =
false
true
*/

, withHoogle  ? false 
#, withLLVM    ? false

, isProfiled    ? false
, isTested      ? false
, isBenchmarked ? false
, isDocumented  ? false
, isHyperlinked ? true
, isDwarf       ? false

, whichObjectLibrary ? "default"
/* = 
"static" 
"shared"
*/

, whichLinker ? "default"
/* = 
"gold" 
*/

, development   ? true
}:

/* Usage:

nix-shell --argstr compiler ...
ghc7103
ghc802
ghc822
ghc841
ghcHEAD
ghc7103Binary
ghc821Binary
ghcjs
ghcjsHEAD       
integer-simple



  nix-shell
  cabal configure 
  cabal build
  cabal run

*/

########################################
let

### "IMPORTS"

inherit (nixpkgs) pkgs;
inherit (pkgs)    stdenv;
# "import" utilities
inherit (pkgs)       fetchFromGitHub;
inherit (stdenv.lib) optionalAttrs;

lib = import "${nixpkgs.path}/pkgs/development/haskell-modules/lib.nix" { pkgs = nixpkgs; };
haskell = pkgs.haskell.lib; 

/* attrNames pkgs.haskell.lib;
=
addBuildDepend             :: ? -> ?
addBuildDepends            :: ? -> ?
addBuildTool               :: ? -> ?
addBuildTools              :: ? -> ?
addExtraLibraries          :: ? -> ?
addExtraLibrary            :: ? -> ?
addPkgconfigDepend         :: ? -> ?
addPkgconfigDepends        :: ? -> ?
addSetupDepend             :: ? -> ?
addSetupDepends            :: ? -> ?
appendConfigureFlag        :: ? -> ?
appendPatch                :: ? -> ?
appendPatches              :: ? -> ?
buildFromSdist             :: ? -> ?
buildStackProject          :: ? -> ?
buildStrictly              :: ? -> ?
checkUnusedPackages        :: ? -> ?
controlPhases              :: ? -> ?
disableCabalFlag           :: ? -> ?
disableDeadCodeElimination :: ? -> ?
disableHardening           :: ? -> ?
disableLibraryProfiling    :: ? -> ?
disableSharedExecutables   :: ? -> ?
disableSharedLibraries     :: ? -> ?
disableStaticLibraries     :: ? -> ?
doBenchmark                :: ? -> ?
doCheck                    :: ? -> ?
doCoverage                 :: ? -> ?
doDistribute               :: ? -> ?
doHaddock                  :: ? -> ?
doHyperlinkSource          :: ? -> ?
doJailbreak                :: ? -> ?
doStrip                    :: ? -> ?
dontBenchmark              :: ? -> ?
dontCheck                  :: ? -> ?
dontCoverage               :: ? -> ?
dontDistribute             :: ? -> ?
dontHaddock                :: ? -> ?
dontHyperlinkSource        :: ? -> ?
dontJailbreak              :: ? -> ?
dontStrip                  :: ? -> ?
enableCabalFlag            :: ? -> ?
enableDWARFDebugging       :: ? -> ?
enableDeadCodeElimination  :: ? -> ?
enableLibraryProfiling     :: ? -> ?
enableSharedExecutables    :: ? -> ?
enableSharedLibraries      :: ? -> ?
enableStaticLibraries      :: ? -> ?
extractBuildInputs         :: ? -> ?
failOnAllWarnings          :: ? -> ?
getHaskellBuildInputs      :: ? -> ?
ghcInfo                    :: ? -> ?
justStaticExecutables      :: ? -> ?
linkWithGold               :: ? -> ?
makePackageSet             :: ? -> ?
markBroken                 :: ? -> ?
markBrokenVersion          :: ? -> ?
overrideCabal              :: ? -> ?
overrideSrc                :: ? -> ?
packageSourceOverrides     :: ? -> ?
removeConfigureFlag        :: ? -> ?
sdistTarball               :: ? -> ?
shellAware                 :: ? -> ?
triggerRebuild             :: ? -> ?

*/

in
########################################
let

### UTILITIES

skipTests       = haskell.dontCheck; 
jailbreak       = haskell.doJailbreak;
dropUpperBounds = haskell.doJailbreak;

#:: String -> Path -> 
execCabal2nix = options: src:
  nixpkgs.runCommand "cabal2nix" {
    buildCommand = ''
      cabal2nix ${options} file://"${src}" >"$out"
    '';
    buildInputs = with nixpkgs; [
      cabal2nix
    ];
  } "";

execCabal2nixSubpath = subpath: src:
  nixpkgs.runCommand "cabal2nix" {
    buildCommand = ''
      cabal2nix --subpath "${subpath}" file://"${src}" >"$out"
    '';
    buildInputs = with nixpkgs; [
      cabal2nix
    ];
  } "";

in
########################################
let

### SOURCE OVERRIDES

# "megarepos" which have multiple packages as subdirectories.
repositories = {

};

# 
sources = {
};

in
########################################
let

customDerivationOptions = 
    { enableLibraryProfiling = isProfiled; 
      doCheck                = isTested; 
      doBenchmark            = isBenchmarked; 
      doHaddock              = isDocumented;
      doHyperlinkSource      = isDocumented && isHyperlinked;
      enableDWARFDebugging   = isDwarf;
    } //
    ( if   (whichObjectLibrary == "shared") 
      then { enableSharedLibraries  = true; 
           }
      else 
      if   (whichObjectLibrary == "static")
      then { enableStaticLibraries  = true; 
           }
      else
      if   (whichObjectLibrary == "both") # TODO
      then { enableSharedLibraries  = true;
             enableStaticLibraries  = true; 
           }
      else 
      if   (whichObjectLibrary == "default")
      then {}
      else {} # TODO
    ) // 
    optionalAttrs (whichLinker == "gold") 
      { linkWithGold = true;
      }
 ;

####################

hooglePackagesOverride = self: super:
  {
    ghcWithPackages = self.ghc.withPackages;

    ghc = super.ghc //
      { withPackages = super.ghc.withHoogle; 
      };
  };

####################

customMkDerivation = self: super: args:
  super.mkDerivation
    (args // customDerivationOptions);

####################

# llvmPackagesOverride = self: super:
#   {
#     ghcWithPackages = self.ghc.withPackages;

#     ghc = super.ghc //
#       { withPackages = super.ghc.llvmPackages; #TODO
#       };
#   };

### COMPILERS

haskellPackagesWithCompiler1 = 

  if   compiler == "default" # `integer-simple` is ignored
  then pkgs.haskellPackages
  else 
  if   integer-simple
  then pkgs.haskell.packages.integer-simple.${compiler}
  else pkgs.haskell.packages.${compiler};

haskellPackagesWithCustomPackages2 =
  if   withHoogle
  then haskellPackagesWithCompiler1.override {
         overrides = hooglePackagesOverride;
       }
  else haskellPackagesWithCompiler1;

haskellPackagesWithCustomDerivation3 = 
  haskellPackagesWithCustomPackages2.override {
    overrides = self: super: {
      mkDerivation = customMkDerivation self super;
    };
  };

# the last referenced, below
# TODO scoping
customizedHaskellPackages = haskellPackagesWithCustomDerivation3;

/*
nix-repl> haskell.packages._

haskell.packages.ghc7103
haskell.packages.ghc821Binary
haskell.packages.ghcHEAD
haskell.packages.integer-simple
haskell.packages.ghc7103Binary
haskell.packages.ghc822
haskell.packages.ghcjs
haskell.packages.ghc802
haskell.packages.ghc841
haskell.packages.ghcjsHEAD       

*/

in
########################################
### Haskell Dependencies...
let

/*

NOTES

* `local` / `github`: 
   They call `import` directly, thus those directories require a `default.nix`
* `cabal2nix` / `hackage` / `github2nix`: 
   They call `cabal2nix`, which generates the `default.nix`, so they don't require the given directory to be a valid `nix` package. 

TYPES
(in pseudo-typed-nix)

type Dependencies = { (Derivation | _) }

nix  : Path -> Dependencies -> Derivation
nix_ : Path ->              -> Derivation

hackage  : String/Name -> String/Version -> Dependencies -> Derivation
hackage_ : String/Name -> String/Version ->              -> Derivation                       

...

*/
myHaskellOverlaysWith = pkgs: self: super: let
#myHaskellOverlaysWith = pkgs: self: super: let

 nixWith    = path:
              self.callPackage path; 

 localWith  = path:
              self.callPackage path; 

 githubWith = o:
              self.callPackage (pkgs.fetchFromGitHub o); 

             # o ::
             #      { owner           :: String
             #        repo            :: String
             #        rev             :: String
             #        fetchSubmodules :: Bool
             #        sha256          :: String
             #      } 

 cabal2nixWith = name: source: 
              self.callCabal2nix name source;

 hackageWith = name: version:
              self.callHackage name version;

 github2nixWith = o:
              cabal2nix o.repo (pkgs.fetchFromGitHub o); 

 # override the package without overriding any dependencies
 nix         = path:           nixWith        path         {};
 local       = path:           localWith      path         {};
 github      = o:              githubWith     o            {};
 cabal2nix   = name: source:   cabal2nixWith  name source  {};
 hackage     = name: version:  hackageWith    name version {};
 github2nix  = o:              github2nixWith o            {};

 #
 haskell = pkgs.haskell.lib; 
 dependsOn = package: dependencies: 
  haskell.addBuildDepends package dependencies;

 in

 # let 
 # reflex_dom = (import repositories.reflex-dom) self pkgs;
 # in

 {
   ########################################
   # Add Haskell Packages Below           #
   ########################################

  spiros = local ../spiros;

  vinyl = skipTests super.vinyl; 

 };

in
########################################
let

### OTHER OVERRIDES
 
modifiedHaskellPackages = customizedHaskellPackages.override {
#  overrides = self: super: {
  overrides = self: super:
    myHaskellOverlaysWith pkgs self super // {
  };
};

in
########################################
let

### DERIVATION / ENVIRONMENT

# theNixFile = ./.;

installationDerivation = modifiedHaskellPackages.callPackage
 packageDotNix {};

# development environment
# for `nix-shell --pure`
developmentDerivation = (haskell.addBuildDepends installationDerivation
 developmentPackages);

developmentPackages
  = developmentHaskellPackages
 # ++ developmentEmacsPackages 
 ++ developmentSystemPackages;

developmentSystemPackages = with pkgs; [
 #   
 cabal-install
 # 
 coreutils
 inotify-tools
 #   
 emacs
 git
 # 
];

developmentHaskellPackages = with modifiedHaskellPackages; [
 #   
 # ghcid
 # ghc-mod
 # 
 # 
 hoogle
 # 
 hasktags
 hlint
 # 
 present
 stylish-haskell
 hindent
 #   
];

 # developmentEmacsHaskellPackages = with Packages; [
 #    dante
 #  ];

environment = haskell.shellAware developmentDerivation;
   # if pkgs.lib.inNixShell then drv.env else drv;

in
########################################

environment

########################################
/*

*/
